Durable Functions is an extension of Azure Functions. You can use Durable Functions for stateful orchestration of function execution. 
A durable function app is a solution that's made up of different Azure functions. 
Functions can play different roles in a durable function orchestration.

<h3>Durable Orchestrations</h3>
Orchestrator functions have the following characteristics:

Orchestrator functions define function workflows using procedural code. No declarative schemas or designers are needed.
Orchestrator functions can call other durable functions synchronously and asynchronously. Output from called functions can be reliably saved to local variables.
Orchestrator functions are durable and reliable. Execution progress is automatically checkpointed when the function "awaits" or "yields". Local state is never lost when the process recycles or the VM reboots.
Orchestrator functions can be long-running. The total lifespan of an orchestration instance can be seconds, days, months, or never-ending.

<h3>Orchestration identity</h3>
Each instance of an orchestration has an instance identifier (also known as an instance ID). By default, each instance ID is an autogenerated GUID. However, instance IDs can also be any user-generated string value. Each orchestration instance ID must be unique within a task hub.

The following are some rules about instance IDs:

Instance IDs must be between 1 and 256 characters.
Instance IDs must not start with @.
Instance IDs must not contain /, \, #, or ? characters.
Instance IDs must not contain control characters.
An orchestration's instance ID is a required parameter for most instance management operations. 
They are also important for diagnostics, such as searching through orchestration tracking data in Application Insights for troubleshooting or analytics purposes. For this reason, it is recommended to save generated instance IDs to some external location 
(for example, a database or in application logs) where they can be easily referenced later.

https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing

<h3>Reliability</h3>

Orchestrator functions reliably maintain their execution state by using the event sourcing design pattern. Instead of directly 
storing the current state of an orchestration, 
the Durable Task Framework uses an append-only store to record the full series of actions the function orchestration takes. 
An append-only store has many benefits compared to "dumping" the full runtime state. Benefits include increased performance, scalability, and responsiveness.

Durable Functions uses event sourcing transparently. Behind the scenes, the await (C#) or yield (JavaScript/Python) operator in an 
orchestrator function yields control of the orchestrator thread back to the Durable Task Framework dispatcher. The dispatcher then commits any new 
actions that the orchestrator function scheduled (such as calling one or more child functions or scheduling a durable timer) to storage. 
The transparent commit action updates the execution history of the orchestration instance by appending all new events into storage, 
much like an append-only log. Similarly, the commit action creates messages in storage to schedule the actual work. 
At this point, the orchestrator function can be unloaded from memory. By default, Durable Functions uses Azure Storage as its runtime state store

When an orchestration function is given more work to do (for example, a response message is received or a durable timer expires), 
the orchestrator wakes up and re-executes the entire function from the start to rebuild the local state. During the replay, 
if the code tries to call a function (or do any other async work), the Durable Task Framework consults the execution history of the current orchestration.
If it finds that the activity function has already executed and yielded a result, it replays that function's result and the orchestrator code continues to run.
Replay continues until the function code is finished or until it has scheduled new async work.

<h3>History table</h3>

Generally speaking, the Durable Task Framework does the following at each checkpoint:
<ul>
<li>Saves execution history into durable storage.</li>
<li>Enqueues messages for functions the orchestrator wants to invoke</li>
<li>Enqueues messages for the orchestrator itself — for example, durable timer messages.</li>
</ul>

<h3><a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-code-constraints">Orchestrator code constraints</a></h3>
A deterministic API is an API that always returns the same value given the same input, no matter when or how often it's called.
